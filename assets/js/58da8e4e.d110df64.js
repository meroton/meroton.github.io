"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5329],{7241:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"improved-chroot-in-buildbarn/implementing-mountat","title":"III Implementing Mountat","description":"Historically you needed absolute filepaths to create mounts,","source":"@site/docs/improved-chroot-in-buildbarn/implementing-mountat.md","sourceDirName":"improved-chroot-in-buildbarn","slug":"/improved-chroot-in-buildbarn/implementing-mountat","permalink":"/docs/improved-chroot-in-buildbarn/implementing-mountat","draft":false,"unlisted":false,"editUrl":"https://github.com/meroton/docs/edit/main/docs/improved-chroot-in-buildbarn/implementing-mountat.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"III Implementing Mountat","sidebar_position":3},"sidebar":"sidebar","previous":{"title":"II The Problem with Special Mounts","permalink":"/docs/improved-chroot-in-buildbarn/the-problem-with-special-filesystems"},"next":{"title":"IV Trying to Implement Unmountat","permalink":"/docs/improved-chroot-in-buildbarn/implementing-unmountat"}}');var i=t(4848),s=t(8453);const r={title:"III Implementing Mountat",sidebar_position:3},a='Create "mountat" with the new Linux mount API',l={},c=[{value:"The new mount API",id:"the-new-mount-api",level:2},{value:"Mount inside a directory file descriptor",id:"mount-inside-a-directory-file-descriptor",level:2},{value:"How do we unmount?",id:"how-do-we-unmount",level:2},{value:"Background on syscalls and c library wrappers",id:"background-on-syscalls-and-c-library-wrappers",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"create-mountat-with-the-new-linux-mount-api",children:'Create "mountat" with the new Linux mount API'})}),"\n",(0,i.jsx)(n.p,{children:'Historically you needed absolute filepaths to create mounts,\nor jump through hoops in syscall land.\nBut with the new mount API we can create a function that mount on relative paths\nthrough a directory file descriptor.\nThis document describes how we implement "mountat".'}),"\n",(0,i.jsxs)(n.p,{children:["Why do we want to use file descriptors?\nWhy do we not use the regular ",(0,i.jsx)(n.code,{children:"mount"})," and just give it an absolute filepath,\nlike regular folks.\nWhy are we fancy?"]}),"\n",(0,i.jsxs)(n.p,{children:["This comes from our work with ",(0,i.jsx)(n.code,{children:"chroot"}),"ing build executors in ",(0,i.jsx)(n.a,{href:"https://github.com/buildbarn/bb-remote-execution",children:"Buildbarn"}),",\nwhere a strict data structure control file operations.\nThis does not export absolute filepaths for the file and directory objects,\nonly relative paths to known root-objects are constructed.\nSo the code guarantees that artifacts are created in the expected locations.\nThis has many benefits in controlling execution flow,\nit seamlessly allows the code to use in-memory files instead of touching a filesystem at all\nand implement usage quotas and other goodies."]}),"\n",(0,i.jsxs)(n.p,{children:["For the purpose of mounting a filesystem,\nthis abstraction has ",(0,i.jsx)(n.em,{children:"veiled"})," the filesystem,\nso we would like to operate on a directory file descriptor.\nThis can be done ",(0,i.jsxs)(n.a,{href:"https://github.com/meroton/prototype-mountat/blob/main/c-prototypes/relative_mount.c",children:["by combining ",(0,i.jsx)(n.code,{children:"mount"})," with ",(0,i.jsx)(n.code,{children:"fchdir"})]}),",\nor to open the file descriptors individually ",(0,i.jsx)(n.a,{href:"https://github.com/lxc/lxc/blob/main/src/lxc/mount_utils.c#L613",children:"lxc project does"}),'.\nbut a full "mountat" is also possible.']}),"\n",(0,i.jsxs)(n.p,{children:["This post will go through how we can implement ",(0,i.jsx)(n.code,{children:"mountat"}),"\nand later posts in the series will discuss unmounting\nand integration with Buildbarn."]}),"\n",(0,i.jsx)(n.h2,{id:"the-new-mount-api",children:"The new mount API"}),"\n",(0,i.jsxs)(n.p,{children:['Recent Linux work from David Howells at Redhat introduced several new syscalls,\nwhich form "new mount API",\nthis is primarily used to speed up work with namespaces and moving mounts back and forth.\nTo break up the monolithic ',(0,i.jsx)(n.code,{children:"mount"})," call into smaller pieces.\nThe benefit (for us) is that it allows relative paths.\nBelow are two example programs that can be used to mount at a relative path,\nor at a directory file descriptor,\nwhich is more convenient for some applications."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Six (or seven) new system calls for filesystem mounting\n",(0,i.jsx)(n.a,{href:"https://lwn.net/Articles/759499/",children:"https://lwn.net/Articles/759499/"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that this is not the final API but describes the background well.\nThe ",(0,i.jsx)(n.code,{children:"write"})," call will not be used at all.\nLater patch sets and the manpages explain the API better,\nbut some vagaries remain as [we will see later]."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Add manpage for fsopen(2), fspick(2) and fsmount(2)\n",(0,i.jsx)(n.a,{href:"https://lwn.net/Articles/802096/",children:"https://lwn.net/Articles/802096/"})]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["[MANPAGE PATCH] Add manpages for move_mount(2) and open_tree(2)\n",(0,i.jsx)(n.a,{href:"https://lore.kernel.org/linux-man/15488.1531263249@warthog.procyon.org.uk/t/",children:"https://lore.kernel.org/linux-man/15488.1531263249@warthog.procyon.org.uk/t/"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Unfortunately I have not found the official man pages anywhere.\nSo the risk of this article being out-of-date is looming.\nJust as the announcement gave examples with ",(0,i.jsx)(n.code,{children:"write"})," that does not work with the real code.\nThis is the ",(0,i.jsx)(n.a,{href:"https://www.kernel.org/doc/Documentation/filesystems/mount_api.txt",children:"general documentation for the API"})," but does not cover our use-cases."]}),"\n",(0,i.jsx)(n.h2,{id:"mount-inside-a-directory-file-descriptor",children:"Mount inside a directory file descriptor"}),"\n",(0,i.jsxs)(n.p,{children:["This creates a named mountpoint in a directory anywhere on the filesystem.\nThis uses a file descriptor for the directory internally,\nthis is the API we will [integrate with Buildbarn].\nWe get the ",(0,i.jsx)(n.code,{children:"at"})," behavior from ",(0,i.jsx)(n.code,{children:"openat"})," here, relative filepaths work just fine.\n",(0,i.jsx)(n.code,{children:"assets/mountat_dfd.c"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'/* Overview of how to implement `mountat` with the new mount API.\n * This does not show proper error handling.\n * It also omits the function wrappers around the syscalls,\n * they can be found in the full code listing.\n */\n\nvoid\nmountat(int dfd, const char *fstype, const char *source, const char *name)\n{\n    int fd = fsopen(fstype, FSOPEN_CLOEXEC);\n    fsconfig(fd, FSCONFIG_SET_STRING, "source", source, 0);\n    fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);\n    int mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);\n    move_mount(mfd, "", dfd, name, MOVE_MOUNT_F_EMPTY_PATH);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    if (argc < 2) {\n        printf("Usage: %s <directory>\\n", argv[0]);\n        exit(1);\n    }\n\n    char* dir = argv[1];\n    int dfd = openat(AT_FDCWD, dir, 0);\n    mountat(dfd, "proc", "/proc", "proc");\n    mountat(dfd, "sysfs", "/sys", "sys");\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Full code is available at [mountat_dfd.c].\nThe code can be run as follows,\nnote the ",(0,i.jsx)(n.code,{children:"strace"})," output of the syscalls\nand how file descriptors pass between the functions.\nThe astute reader knows that we can ",(0,i.jsx)(n.em,{children:"golf"})," away the ",(0,i.jsx)(n.code,{children:"openat"}),"\nif we want to create the mounts directly inside the working directory."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ mkdir -p /tmp/test-relative-mount-at2/{sys,proc}\n$ gcc mountat_dfd.c\n$ sudo strace -s1000 -f -o trace ./a.out /tmp/test-relative-mount-at2/\n$ grep -e openat -e fsopen -e fsconfig -e fsmount -e move_mount trace\n877364 openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3\n877364 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3\n877364 openat(AT_FDCWD, "/tmp/test-relative-mount-at2/", O_RDONLY) = 3\n877364 fsopen("proc", FSOPEN_CLOEXEC)   = 4\n877364 fsconfig(4, FSCONFIG_SET_STRING, "source", "/proc", 0) = 0\n877364 fsconfig(4, FSCONFIG_CMD_CREATE, NULL, NULL, 0) = 0\n877364 fsmount(4, FSMOUNT_CLOEXEC, MOUNT_ATTR_NOEXEC) = 5\n877364 move_mount(5, "", 3, "proc", MOVE_MOUNT_F_EMPTY_PATH) = 0\n877364 fsopen("sysfs", FSOPEN_CLOEXEC)  = 6\n877364 fsconfig(6, FSCONFIG_SET_STRING, "source", "/sys", 0) = 0\n877364 fsconfig(6, FSCONFIG_CMD_CREATE, NULL, NULL, 0) = 0\n877364 fsmount(6, FSMOUNT_CLOEXEC, MOUNT_ATTR_NOEXEC) = 7\n877364 move_mount(7, "", 3, "sys", MOVE_MOUNT_F_EMPTY_PATH) = 0\n'})}),"\n",(0,i.jsxs)(n.p,{children:["See the ",(0,i.jsx)(n.a,{href:"https://github.com/meroton/prototype-mountat/blob/main/README.rst",children:"prototype Readme"})," for more information about running these programs."]}),"\n",(0,i.jsx)(n.h2,{id:"how-do-we-unmount",children:"How do we unmount?"}),"\n",(0,i.jsxs)(n.p,{children:['Unfortunately the "new mount API" does not provide a clear way to unmount from relative paths.\nWe would like to pair this with ',(0,i.jsx)(n.code,{children:"umountat"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Quote the manpages:"}),"\n",(0,i.jsx)(n.p,{children:"move_mount () is called repeatedly with a file descriptor that refers to a mount object,\nthen the object will be attached/moved the first time and then moved again and\nagain and again, detaching it from the previous mountpoint each time."}),"\n",(0,i.jsxs)(n.p,{children:["But this was not enough for us to implement ",(0,i.jsx)(n.code,{children:"umountat"}),".\nThankfully we can make do without it."]}),"\n",(0,i.jsx)(n.h2,{id:"background-on-syscalls-and-c-library-wrappers",children:"Background on syscalls and c library wrappers"}),"\n",(0,i.jsxs)(n.p,{children:["All the prototype code have special wrapper functions for the syscalls,\nthat specify the syscall number and pass arguments.\nThis is typically done by ",(0,i.jsx)(n.code,{children:"glibc"})," and not needed in program code,\nhowever, these new syscalls are not available in older versions,\n(they were introduced to ",(0,i.jsx)(n.code,{children:"glibc"})," in ",(0,i.jsx)(n.a,{href:"https://www.phoronix.com/news/GNU-C-Library-Glibc-2.36",children:"version 2.36"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["In the go code this typically lives in the ",(0,i.jsx)(n.code,{children:"unix"})," package,\nand the ",(0,i.jsx)(n.code,{children:"glibc"})," is not used when building statically linked binaries.\nThe majority of the syscalls in the new mount API are merged,\nbut ",(0,i.jsx)(n.code,{children:"fsconfig"})," is ",(0,i.jsx)(n.a,{href:"https://github.com/golang/go/issues/59537",children:"not merged yet"}),", so a simple implementation is provided just for the code we exercise,\nas that is more complex than most syscalls."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);