"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[184],{2852:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var t=i(5893),o=i(1151);const a={sidebar_position:1},r="Components of a Build",s={id:"theory/components-of-a-build",title:"Components of a Build",description:"A build is a pretty abstract concept, for many developers it's what happens when you press f5 but before your application starts. So what does happen when you press f5? Well that depends on your underlying environment, but in general it runs a couple of actions.",source:"@site/docs/theory/components-of-a-build.md",sourceDirName:"theory",slug:"/theory/components-of-a-build",permalink:"/docs/theory/components-of-a-build",draft:!1,unlisted:!1,editUrl:"https://github.com/meroton/docs/edit/main/docs/theory/components-of-a-build.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"sidebar",previous:{title:"Introduction",permalink:"/docs/intro"},next:{title:"Automatically reformat all commits on a branch",permalink:"/docs/practice/rebase-and-reformat-git-branches-automatically"}},c={},l=[{value:"What is an Action?",id:"what-is-an-action",level:2},{value:"Incremental Builds",id:"incremental-builds",level:2},{value:"Deterministic Compilations",id:"deterministic-compilations",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"components-of-a-build",children:"Components of a Build"}),"\n",(0,t.jsxs)(n.p,{children:["A build is a pretty abstract concept, for many developers it's what happens when you press ",(0,t.jsx)(n.code,{children:"f5"})," but before your application starts. So what does happen when you press ",(0,t.jsx)(n.code,{children:"f5"}),"? Well that depends on your underlying environment, but in general it runs a couple of actions."]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-an-action",children:"What is an Action?"}),"\n",(0,t.jsxs)(n.p,{children:["An action is something that takes input and produces output, an example of a simple action could be described by the command ",(0,t.jsx)(n.code,{children:"cp\xa0example.txt\xa0example-copy.txt"})," which executes the executable ",(0,t.jsx)(n.code,{children:"cp"})," with ",(0,t.jsx)(n.code,{children:"example.txt"})," as its input and creates ",(0,t.jsx)(n.code,{children:"example-copy.txt"})," as its output."]}),"\n",(0,t.jsxs)(n.p,{children:["For a more relevant but still small example consider the following ",(0,t.jsx)(n.code,{children:"C"})," project which consists of a static library ",(0,t.jsx)(n.code,{children:"lib"})," and a ",(0,t.jsx)(n.code,{children:"main.c"})," file consuming that library."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// main.c\n#include "lib.h"\n\nvoid main() {\n  hello();\n}\n\n---\n\n// lib.h\nvoid hello();\nvoid world();\n\n---\n\n// lib.c\n#include "lib.h"\n#include "stdio.h"\n\nvoid hello() {\n  printf("Hello ");\n}\n\nvoid world() {\n  printf("World!);\n}\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"We can compile this project with these 4 commands each representing an action"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:" $> cc -c -o lib.o lib.c      # compile library into object file\n $> ar rcs lib.a lib.o        # turn library object files into a static library (an archive)\n $> cc -c -o main.o main.c    # compile main.c into an object file\n $> cc main.o lib.a -o main   # link our library and our object file into an executable\n"})}),"\n",(0,t.jsx)(n.h2,{id:"incremental-builds",children:"Incremental Builds"}),"\n",(0,t.jsxs)(n.p,{children:["The previous actions can be displayed with this dependency graph",(0,t.jsx)("sup",{children:(0,t.jsx)(n.a,{href:"#note-1",children:"1"})})]}),"\n",(0,t.jsx)("a",{title:"Simplified dependency graph for our example",href:"#note-1",children:(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{alt:"",src:"/img/dependency_graph.drawio.svg"}),(0,t.jsx)("figcaption",{})]})}),"\n",(0,t.jsxs)(n.p,{children:["If we make a small modification to the ",(0,t.jsx)(n.code,{children:"main.c"})," file"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// main.c\n#include "lib.h"\n\nvoid main() {\n  hello();\n  world();\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Then we only have to perform two actions, recompiling the ",(0,t.jsx)(n.code,{children:"main.c"})," file and relinking (this is what is usually called an incremental build)."]}),"\n",(0,t.jsx)("a",{title:"Incremental build graph for our example",children:(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{alt:"",src:"/img/dependency_graph_incremental.drawio.svg"}),(0,t.jsx)("figcaption",{})]})}),"\n",(0,t.jsx)(n.p,{children:"A lot of developers have issues with their incremental builds where they are not stable, therefore requiring a clean build before building again. There are a few common reasons this would happen:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Race conditions, files can be modified during the build leading to some files incorrectly being consided unchanged since the last build"}),"\n",(0,t.jsx)(n.li,{children:"Imperfect method of checking for changes, such as comparing timestamps of the files instead of the content"}),"\n",(0,t.jsx)(n.li,{children:"Changed but unspecified dependencies, happens when your dependency graph is incomplete"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In a large project the vast majority of files will be untouched in between two different builds, therefore developers can expect a huge performance increase by by making sure that the incremental builds work correctly, as well as saving them a lot of headaches about peculiar bugs happening randomly."}),"\n",(0,t.jsx)(n.h2,{id:"deterministic-compilations",children:"Deterministic Compilations"}),"\n",(0,t.jsx)(n.p,{children:"The dependency graph helps us figure out which actions might need to be rerun, but sometimes an action might result in the same result as before. In that case we wouldn't want unnecessary actions to run further down in the tree."}),"\n",(0,t.jsx)(n.p,{children:"Consider the case where we add a comment to our header file, documenting what the code does."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// lib.h\n\n// Prints "Hello" to the standard output\nvoid hello();\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Studying our dependency graph we see that we need to compilate of ",(0,t.jsx)(n.code,{children:"lib.o"})," as well as a compilation of ",(0,t.jsx)(n.code,{children:"main.o"})," the output of those compilations do not change. This means the creation of a static library and the linking step can be short-circuited and the result of the previous compilation returned instead."]}),"\n",(0,t.jsx)("a",{title:"Short-circuited incremental build graph for our example",children:(0,t.jsxs)("figure",{children:[(0,t.jsx)("img",{alt:"",src:"/img/dependency_graph_short_circuited.drawio.svg"}),(0,t.jsx)("figcaption",{})]})}),"\n",(0,t.jsx)(n.p,{children:"This works because our build step is reproducible (often called a deterministic build), running it several times produces the exact same output. For the vast majority of software this is the intended behaviour. There are several advantages to having reproducible builds and there are very few valid reasons not to. However, sometimes the world doesn't work the way we want it to and fixing the issue is outside of our power, perhaps a piece of third party software is adding random timestamps or ids to the output. At those times you can often ignore the issue, try to move the non-determinism away from hot paths is your code so as to minimize the amount of wasted effort."}),"\n",(0,t.jsx)(n.p,{children:"If you purposefully want the output to be non-deterministic it is better to add a dependency to a random source than to introduce it in your codebase, i.e. have the current time or a random seed as a dependency."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)("span",{id:"note-1",children:"Note 1:"}),"\n",(0,t.jsxs)(n.p,{children:["As a simplification we do not illustrate the implied action dependencies. I.e. ",(0,t.jsx)(n.code,{children:"main.o"})," is not dependent on ",(0,t.jsx)(n.code,{children:"main.c"})," or ",(0,t.jsx)(n.code,{children:"lib.h"})," but only on the action described by ",(0,t.jsx)(n.code,{children:"cc -c main.c -o main.o"})," which in turn is dependent on ",(0,t.jsx)(n.code,{children:"main.c"})," and ",(0,t.jsx)(n.code,{children:"lib.h"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["There are also a few implied dependencies here, notably the compiler, the c-standard library and its header files (usually located in ",(0,t.jsx)(n.code,{children:"/usr/include"}),") as well as a few implied flags about compilation target. This is rarely a problem for the standard library but when you include more esoteric libraries version incompatibilities will rear its ugly head. This entire class of problem can be eliminated by containerizing our builds, i.e. the compilation is run by a well defined compiler inside a container, the container becomes part of the dependency graph and any forgotten dependencies will become immediately apparent (since the container wont know of them)."]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>s,a:()=>r});var t=i(7294);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);